% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/layers-rnn.R
\name{layer_gru}
\alias{layer_gru}
\title{Gated Recurrent Unit - Cho et al. 2014.}
\usage{
layer_gru(
  object,
  units,
  activation = "tanh",
  recurrent_activation = "sigmoid",
  use_bias = TRUE,
  kernel_initializer = "glorot_uniform",
  recurrent_initializer = "orthogonal",
  bias_initializer = "zeros",
  kernel_regularizer = NULL,
  recurrent_regularizer = NULL,
  bias_regularizer = NULL,
  activity_regularizer = NULL,
  kernel_constraint = NULL,
  recurrent_constraint = NULL,
  bias_constraint = NULL,
  dropout = 0,
  recurrent_dropout = 0,
  seed = NULL,
  return_sequences = FALSE,
  return_state = FALSE,
  go_backwards = FALSE,
  stateful = FALSE,
  unroll = FALSE,
  reset_after = TRUE,
  use_cudnn = "auto",
  ...
)
}
\arguments{
\item{object}{Object to compose the layer with. A tensor, array, or sequential model.}

\item{units}{Positive integer, dimensionality of the output space.}

\item{activation}{Activation function to use.
Default: hyperbolic tangent (\code{tanh}).
If you pass \code{NULL}, no activation is applied
(ie. "linear" activation: \code{a(x) = x}).}

\item{recurrent_activation}{Activation function to use
for the recurrent step.
Default: sigmoid (\code{sigmoid}).
If you pass \code{NULL}, no activation is applied
(ie. "linear" activation: \code{a(x) = x}).}

\item{use_bias}{Boolean, (default \code{TRUE}), whether the layer
should use a bias vector.}

\item{kernel_initializer}{Initializer for the \code{kernel} weights matrix,
used for the linear transformation of the inputs. Default:
\code{"glorot_uniform"}.}

\item{recurrent_initializer}{Initializer for the \code{recurrent_kernel}
weights matrix, used for the linear transformation of the recurrent
state. Default: \code{"orthogonal"}.}

\item{bias_initializer}{Initializer for the bias vector. Default: \code{"zeros"}.}

\item{kernel_regularizer}{Regularizer function applied to the \code{kernel} weights
matrix. Default: \code{NULL}.}

\item{recurrent_regularizer}{Regularizer function applied to the
\code{recurrent_kernel} weights matrix. Default: \code{NULL}.}

\item{bias_regularizer}{Regularizer function applied to the bias vector.
Default: \code{NULL}.}

\item{activity_regularizer}{Regularizer function applied to the output of the
layer (its "activation"). Default: \code{NULL}.}

\item{kernel_constraint}{Constraint function applied to the \code{kernel} weights
matrix. Default: \code{NULL}.}

\item{recurrent_constraint}{Constraint function applied to the
\code{recurrent_kernel} weights matrix. Default: \code{NULL}.}

\item{bias_constraint}{Constraint function applied to the bias vector.
Default: \code{NULL}.}

\item{dropout}{Float between 0 and 1. Fraction of the units to drop for the
linear transformation of the inputs. Default: 0.}

\item{recurrent_dropout}{Float between 0 and 1. Fraction of the units to drop
for the linear transformation of the recurrent state. Default: 0.}

\item{seed}{Random seed for dropout.}

\item{return_sequences}{Boolean. Whether to return the last output
in the output sequence, or the full sequence. Default: \code{FALSE}.}

\item{return_state}{Boolean. Whether to return the last state in addition
to the output. Default: \code{FALSE}.}

\item{go_backwards}{Boolean (default \code{FALSE}).
If \code{TRUE}, process the input sequence backwards and return the
reversed sequence.}

\item{stateful}{Boolean (default: \code{FALSE}). If \code{TRUE}, the last state
for each sample at index i in a batch will be used as initial
state for the sample of index i in the following batch.}

\item{unroll}{Boolean (default: \code{FALSE}).
If \code{TRUE}, the network will be unrolled,
else a symbolic loop will be used.
Unrolling can speed-up a RNN,
although it tends to be more memory-intensive.
Unrolling is only suitable for short sequences.}

\item{reset_after}{GRU convention (whether to apply reset gate after or
before matrix multiplication). \code{FALSE} is \code{"before"},
\code{TRUE} is \code{"after"} (default and cuDNN compatible).}

\item{use_cudnn}{Whether to use a cuDNN-backed implementation. \code{"auto"} will
attempt to use cuDNN when feasible, and will fallback to the
default implementation if not.}

\item{...}{For forward/backward compatability.}
}
\value{
The return value depends on the value provided for the first argument.
If  \code{object} is:
\itemize{
\item a \code{keras_model_sequential()}, then the layer is added to the sequential model
(which is modified in place). To enable piping, the sequential model is also
returned, invisibly.
\item a \code{keras_input()}, then the output tensor from calling \code{layer(input)} is returned.
\item \code{NULL} or missing, then a \code{Layer} instance is returned.
}
}
\description{
Based on available runtime hardware and constraints, this layer
will choose different implementations (cuDNN-based or backend-native)
to maximize the performance. If a GPU is available and all
the arguments to the layer meet the requirement of the cuDNN kernel
(see below for details), the layer will use a fast cuDNN implementation
when using the TensorFlow backend.

The requirements to use the cuDNN implementation are:
\enumerate{
\item \code{activation} == \code{tanh}
\item \code{recurrent_activation} == \code{sigmoid}
\item \code{dropout} == 0 and \code{recurrent_dropout} == 0
\item \code{unroll} is \code{FALSE}
\item \code{use_bias} is \code{TRUE}
\item \code{reset_after} is \code{TRUE}
\item Inputs, if use masking, are strictly right-padded.
\item Eager execution is enabled in the outermost context.
}

There are two variants of the GRU implementation. The default one is based
on \href{https://arxiv.org/abs/1406.1078v3}{v3} and has reset gate applied to
hidden state before matrix multiplication. The other one is based on
\href{https://arxiv.org/abs/1406.1078v1}{original} and has the order reversed.

The second variant is compatible with CuDNNGRU (GPU-only) and allows
inference on CPU. Thus it has separate biases for \code{kernel} and
\code{recurrent_kernel}. To use this variant, set \code{reset_after=TRUE} and
\code{recurrent_activation='sigmoid'}.

For example:

\if{html}{\out{<div class="sourceCode r">}}\preformatted{inputs <- random_uniform(c(32, 10, 8))
outputs <- inputs |> layer_gru(4)
shape(outputs)
}\if{html}{\out{</div>}}

\if{html}{\out{<div class="sourceCode">}}\preformatted{## shape(32, 4)

}\if{html}{\out{</div>}}

\if{html}{\out{<div class="sourceCode r">}}\preformatted{# (32, 4)
gru <- layer_gru(, 4, return_sequences = TRUE, return_state = TRUE)
c(whole_sequence_output, final_state) \%<-\% gru(inputs)
shape(whole_sequence_output)
}\if{html}{\out{</div>}}

\if{html}{\out{<div class="sourceCode">}}\preformatted{## shape(32, 10, 4)

}\if{html}{\out{</div>}}

\if{html}{\out{<div class="sourceCode r">}}\preformatted{shape(final_state)
}\if{html}{\out{</div>}}

\if{html}{\out{<div class="sourceCode">}}\preformatted{## shape(32, 4)

}\if{html}{\out{</div>}}
}
\section{Call Arguments}{
\itemize{
\item \code{inputs}: A 3D tensor, with shape \verb{(batch, timesteps, feature)}.
\item \code{mask}: Binary tensor of shape \verb{(samples, timesteps)} indicating whether
a given timestep should be masked  (optional).
An individual \code{TRUE} entry indicates that the corresponding timestep
should be utilized, while a \code{FALSE} entry indicates that the
corresponding timestep should be ignored. Defaults to \code{NULL}.
\item \code{training}: Python boolean indicating whether the layer should behave in
training mode or in inference mode. This argument is passed to the
cell when calling it. This is only relevant if \code{dropout} or
\code{recurrent_dropout} is used  (optional). Defaults to \code{NULL}.
\item \code{initial_state}: List of initial state tensors to be passed to the first
call of the cell (optional, \code{NULL} causes creation
of zero-filled initial state tensors). Defaults to \code{NULL}.
}
}

\seealso{
\itemize{
\item \url{https://keras.io/api/layers/recurrent_layers/gru#gru-class}
}

Other gru rnn layers: \cr
\code{\link{rnn_cell_gru}()} \cr

Other rnn layers: \cr
\code{\link{layer_bidirectional}()} \cr
\code{\link{layer_conv_lstm_1d}()} \cr
\code{\link{layer_conv_lstm_2d}()} \cr
\code{\link{layer_conv_lstm_3d}()} \cr
\code{\link{layer_lstm}()} \cr
\code{\link{layer_rnn}()} \cr
\code{\link{layer_simple_rnn}()} \cr
\code{\link{layer_time_distributed}()} \cr
\code{\link{rnn_cell_gru}()} \cr
\code{\link{rnn_cell_lstm}()} \cr
\code{\link{rnn_cell_simple}()} \cr
\code{\link{rnn_cells_stack}()} \cr

Other layers: \cr
\code{\link{Layer}()} \cr
\code{\link{layer_activation}()} \cr
\code{\link{layer_activation_elu}()} \cr
\code{\link{layer_activation_leaky_relu}()} \cr
\code{\link{layer_activation_parametric_relu}()} \cr
\code{\link{layer_activation_relu}()} \cr
\code{\link{layer_activation_softmax}()} \cr
\code{\link{layer_activity_regularization}()} \cr
\code{\link{layer_add}()} \cr
\code{\link{layer_additive_attention}()} \cr
\code{\link{layer_alpha_dropout}()} \cr
\code{\link{layer_attention}()} \cr
\code{\link{layer_auto_contrast}()} \cr
\code{\link{layer_average}()} \cr
\code{\link{layer_average_pooling_1d}()} \cr
\code{\link{layer_average_pooling_2d}()} \cr
\code{\link{layer_average_pooling_3d}()} \cr
\code{\link{layer_batch_normalization}()} \cr
\code{\link{layer_bidirectional}()} \cr
\code{\link{layer_category_encoding}()} \cr
\code{\link{layer_center_crop}()} \cr
\code{\link{layer_concatenate}()} \cr
\code{\link{layer_conv_1d}()} \cr
\code{\link{layer_conv_1d_transpose}()} \cr
\code{\link{layer_conv_2d}()} \cr
\code{\link{layer_conv_2d_transpose}()} \cr
\code{\link{layer_conv_3d}()} \cr
\code{\link{layer_conv_3d_transpose}()} \cr
\code{\link{layer_conv_lstm_1d}()} \cr
\code{\link{layer_conv_lstm_2d}()} \cr
\code{\link{layer_conv_lstm_3d}()} \cr
\code{\link{layer_cropping_1d}()} \cr
\code{\link{layer_cropping_2d}()} \cr
\code{\link{layer_cropping_3d}()} \cr
\code{\link{layer_dense}()} \cr
\code{\link{layer_depthwise_conv_1d}()} \cr
\code{\link{layer_depthwise_conv_2d}()} \cr
\code{\link{layer_discretization}()} \cr
\code{\link{layer_dot}()} \cr
\code{\link{layer_dropout}()} \cr
\code{\link{layer_einsum_dense}()} \cr
\code{\link{layer_embedding}()} \cr
\code{\link{layer_equalization}()} \cr
\code{\link{layer_feature_space}()} \cr
\code{\link{layer_flatten}()} \cr
\code{\link{layer_flax_module_wrapper}()} \cr
\code{\link{layer_gaussian_dropout}()} \cr
\code{\link{layer_gaussian_noise}()} \cr
\code{\link{layer_global_average_pooling_1d}()} \cr
\code{\link{layer_global_average_pooling_2d}()} \cr
\code{\link{layer_global_average_pooling_3d}()} \cr
\code{\link{layer_global_max_pooling_1d}()} \cr
\code{\link{layer_global_max_pooling_2d}()} \cr
\code{\link{layer_global_max_pooling_3d}()} \cr
\code{\link{layer_group_normalization}()} \cr
\code{\link{layer_group_query_attention}()} \cr
\code{\link{layer_hashed_crossing}()} \cr
\code{\link{layer_hashing}()} \cr
\code{\link{layer_identity}()} \cr
\code{\link{layer_integer_lookup}()} \cr
\code{\link{layer_jax_model_wrapper}()} \cr
\code{\link{layer_lambda}()} \cr
\code{\link{layer_layer_normalization}()} \cr
\code{\link{layer_lstm}()} \cr
\code{\link{layer_masking}()} \cr
\code{\link{layer_max_num_bounding_boxes}()} \cr
\code{\link{layer_max_pooling_1d}()} \cr
\code{\link{layer_max_pooling_2d}()} \cr
\code{\link{layer_max_pooling_3d}()} \cr
\code{\link{layer_maximum}()} \cr
\code{\link{layer_mel_spectrogram}()} \cr
\code{\link{layer_minimum}()} \cr
\code{\link{layer_mix_up}()} \cr
\code{\link{layer_multi_head_attention}()} \cr
\code{\link{layer_multiply}()} \cr
\code{\link{layer_normalization}()} \cr
\code{\link{layer_permute}()} \cr
\code{\link{layer_rand_augment}()} \cr
\code{\link{layer_random_brightness}()} \cr
\code{\link{layer_random_color_degeneration}()} \cr
\code{\link{layer_random_color_jitter}()} \cr
\code{\link{layer_random_contrast}()} \cr
\code{\link{layer_random_crop}()} \cr
\code{\link{layer_random_flip}()} \cr
\code{\link{layer_random_grayscale}()} \cr
\code{\link{layer_random_hue}()} \cr
\code{\link{layer_random_posterization}()} \cr
\code{\link{layer_random_rotation}()} \cr
\code{\link{layer_random_saturation}()} \cr
\code{\link{layer_random_sharpness}()} \cr
\code{\link{layer_random_shear}()} \cr
\code{\link{layer_random_translation}()} \cr
\code{\link{layer_random_zoom}()} \cr
\code{\link{layer_repeat_vector}()} \cr
\code{\link{layer_rescaling}()} \cr
\code{\link{layer_reshape}()} \cr
\code{\link{layer_resizing}()} \cr
\code{\link{layer_rnn}()} \cr
\code{\link{layer_separable_conv_1d}()} \cr
\code{\link{layer_separable_conv_2d}()} \cr
\code{\link{layer_simple_rnn}()} \cr
\code{\link{layer_solarization}()} \cr
\code{\link{layer_spatial_dropout_1d}()} \cr
\code{\link{layer_spatial_dropout_2d}()} \cr
\code{\link{layer_spatial_dropout_3d}()} \cr
\code{\link{layer_spectral_normalization}()} \cr
\code{\link{layer_stft_spectrogram}()} \cr
\code{\link{layer_string_lookup}()} \cr
\code{\link{layer_subtract}()} \cr
\code{\link{layer_text_vectorization}()} \cr
\code{\link{layer_tfsm}()} \cr
\code{\link{layer_time_distributed}()} \cr
\code{\link{layer_torch_module_wrapper}()} \cr
\code{\link{layer_unit_normalization}()} \cr
\code{\link{layer_upsampling_1d}()} \cr
\code{\link{layer_upsampling_2d}()} \cr
\code{\link{layer_upsampling_3d}()} \cr
\code{\link{layer_zero_padding_1d}()} \cr
\code{\link{layer_zero_padding_2d}()} \cr
\code{\link{layer_zero_padding_3d}()} \cr
\code{\link{rnn_cell_gru}()} \cr
\code{\link{rnn_cell_lstm}()} \cr
\code{\link{rnn_cell_simple}()} \cr
\code{\link{rnn_cells_stack}()} \cr
}
\concept{gru rnn layers}
\concept{layers}
\concept{rnn layers}
